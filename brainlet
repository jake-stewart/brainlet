#!/usr/bin/env python3

# MIT License
# 
# Copyright (c) 2024 Jake Stewart
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import sys
import textwrap
import shutil
import unicodedata
import argparse

def is_double_width(c):
    return unicodedata.east_asian_width(c) in ["F", "W"]

glyphs = {
    "A": [
        "╭─╮",
        "├─┤",
        "╵ ╵"
    ],
    # "A": [
    #     "╭─╮",
    #     "╭─┤",
    #     "╰─╯"
    # ],
    "B": [
        "┌╮ ",
        "├┴╮",
        "└─╯"
    ],
    # "B": [
    #     "╷  ",
    #     "├─╮",
    #     "└─╯"
    # ],
    "C": [
        "╭─╮",
        "│  ",
        "╰─╯"
    ],
    "D": [
        "┌─╮",
        "│ │",
        "└─╯"
    ],
    # "D": [
    #     "  ╷",
    #     "╭─┤",
    #     "╰─┘"
    # ],
    "E": [
        "╭─╴",
        "├─╴",
        "╰─╴"
    ],
    # "E": [
    #     "╭─╮",
    #     "├─┘",
    #     "╰─╯"
    # ],
    "F": [
        "╭─╴",
        "├─╴",
        "╵  "
    ],
    # "F": [
    #     " ╭─",
    #     "╶┼─",
    #     " ╵ "
    # ],
    "G": [
        "╭─╮",
        "│╶┐",
        "╰─╯"
    ],
    # "G": [
    #     "╭─╮",
    #     "╰─┤",
    #     "╰─╯"
    # ],
    "H": [
        "╷ ╷",
        "├─┤",
        "╵ ╵"
    ],
    # "H": [
    #     "╷  ",
    #     "├─╮",
    #     "╵ ╵"
    # ],
    "I": [
        "╶┬╴",
        " │ ",
        "╶┴╴"
    ],
    # "I": [
    #     " · ",
    #     "╶┐ ",
    #     "╶┴╴"
    # ],
    "J": [
        "  ╷",
        "  │",
        "╰─╯"
    ],
    # "J": [
    #     "  ·",
    #     "  │",
    #     "╰─╯"
    # ],
    "K": [
        "╷╭╴",
        "├┴╮",
        "╵ ╰"
    ],
    "L": [
        "╷  ",
        "│  ",
        "╰─╴"
    ],
    # "L": [
    #     "╶╮ ",
    #     " │ ",
    #     "╶┴╴"
    # ],
    "M": [
        "╭┬╮",
        "│││",
        "╵ ╵"
    ],
    "N": [
        "┌─╮",
        "│ │",
        "╵ ╵"
    ],
    # "N": [
    #     "┌╮╷",
    #     "│││",
    #     "╵└╯"
    # ],
    "O": [
        "╭─╮",
        "│ │",
        "╰─╯"
    ],
    "P": [
        "┌─╮",
        "├─╯",
        "╵  "
    ],
    "Q": [
        "╭─╮",
        "│╶┼",
        "╰─╯"
    ],
    # "Q": [
    #     "╭─┐",
    #     "╰─┤",
    #     "  ╰"
    # ],
    "R": [
        "┌─╮",
        "├┬╯",
        "╵╰╴"
    ],
    # "R": [
    #     "╭─╮",
    #     "│  ",
    #     "╵  "
    # ],
    "S": [
        "╭─╮",
        "╰─╮",
        "╰─╯"
    ],
    "T": [
        "╶┬╴",
        " │ ",
        " ╵ "
    ],
    # "T": [
    #     "╭┬╮",
    #     " │ ",
    #     " ╵ "
    # ],
    # "T": [
    #     " ╷ ",
    #     "╶┼╴",
    #     " ╰╴"
    # ],
    "U": [
        "╷ ╷",
        "│ │",
        "╰─╯"
    ],
    # "U": [
    #     "╷ ╷",
    #     "│ │",
    #     "╰─┘"
    # ],
    "V": [
        "╶╮╷",
        " ││",
        " ╰╯"
    ],
    "W": [
        "╷ ╷",
        "│││",
        "╰┴╯"
    ],
    "X": [
        "╭┬╮",
        " │ ",
        "╰┴╯"
    ],
    "Y": [
        "╷ ╷",
        "╰┬╯",
        " ╵ "
    ],
    # "Y": [
    #     "╷ ╷",
    #     "╰─┤",
    #     "╰─╯"
    # ],
    "Z": [
        "╶─╮",
        "╭─╯",
        "╰─╴"
    ],
    "1": [
        "╶┐ ",
        " │ ",
        "╶┴╴"
    ],
    "2": [
        "╶─╮",
        "╭─╯",
        "└─╴"
    ],
    "3": [
        "╶─╮",
        "╶─┤",
        "╶─╯"
    ],
    "4": [
        "╷ ╷",
        "╰─┤",
        "  ╵"
    ],
    "5": [
        "┌─╴",
        "╰─╮",
        "╰─╯"
    ],
    "6": [
        "╭─╮",
        "├─╮",
        "╰─╯"
    ],
    "7": [
        "╶─╮",
        "  │",
        "  ╵"
    ],
    # "7": [
    #     "╶─┐",
    #     "  ┼",
    #     "  ╵"
    # ],
    "8": [
        "╭─╮",
        "├─┤",
        "╰─╯"
    ],
    "9": [
        "╭─╮",
        "╰─┤",
        "╰─╯"
    ],
    "0": [
        "╭─╮",
        "│││",
        "╰─╯"
    ],
    "{": [
        " ╭╴",
        " ┤ ",
        " ╰╴"
    ],
    "}": [
        "╶╮ ",
        " ├ ",
        "╶╯ "
    ],
    "(": [
        " ╭╴",
        " │ ",
        " ╰╴"
    ],
    ")": [
        "╶╮ ",
        " │ ",
        "╶╯ "
    ],
    "[": [
        " ┌╴",
        " │ ",
        " └╴"
    ],
    "]": [
        "╶┐ ",
        " │ ",
        "╶┘ "
    ],
    "~": [
        "╭─╯",
        "   ",
        "   "
    ],
    "`": [
        " ` ",
        "   ",
        "   "
    ],
    # "`": [
    #     " \\ ",
    #     "   ",
    #     "   "
    # ],
    "'": [
        " ╷ ",
        "   ",
        "   "
    ],
    ".": [
        "   ",
        "   ",
        " · "
    ],
    ",": [
        "   ",
        "   ",
        " ╷ "
    ],
    ";": [
        "   ",
        " · ",
        " ╷ "
    ],
    ":": [
        "   ",
        " · ",
        " · "
    ],
    "-": [
        "   ",
        "╶─╴",
        "   "
    ],
    "+": [
        "   ",
        "╶┼╴",
        "   "
    ],
    # "=": [
    #     "   ",
    #     "╶─╴",
    #     "╶─╴"
    # ],
    "|": [
        " ╷ ",
        " │ ",
        " ╵ "
    ],
    '"': [
        " ╷╷",
        "   ",
        "   "
    ],
    "?": [
        "╭─╮",
        " ╭╯",
        " · "
    ],
    "!": [
        " ╷ ",
        " │ ",
        " · "
    ],
    "&": [
        "╭╮ ",
        "╭┼╯",
        "╰╯ "
    ],
    "$": [
        "╭┴╮",
        "╰─╮",
        "╰┬╯"
    ],
    # "%": [
    #     "╭╮╷",
    #     "╰┼╮",
    #     "╵╰╯"
    # ],
    "@": [
        "╭─╮",
        "├╮│",
        "╰╯╯"
    ],
    # "^": [
    #     " ╭╮",
    #     "   ",
    #     "   "
    # ],
    # "#": [
    #     "┼─┼",
    #     "┼─┼",
    #     "   "
    # ],
    "/": [
        "  ╱",
        " ╱ ",
        "╱  "
    ],
    "\\": [
        "╲  ",
        " ╲ ",
        "  ╲"
    ],
    "_": [
        "   ",
        "   ",
        "╶─╴"
    ],
}

def brainlet(s):
    output_buffers = [[], [], []]
    for letter in s:
        if not letter.isprintable():
            continue
        try:
            glyph_lines = glyphs[letter.upper()]

            for i, line in enumerate(glyph_lines):
                output_buffers[i].append(line)
        except KeyError:
            output_buffers[0].append("   ")
            if not is_double_width(letter):
                output_buffers[1].append(" ")
            output_buffers[1].append(letter)
            output_buffers[1].append(" ")
            output_buffers[2].append("   ")
    return output_buffers

def print_brainlet(s, align, width):
    if width:
        lines = textwrap.wrap(s, width)
    else:
        lines = [s]

    for i, line in enumerate(lines):
        remaining_space = width - len(line)
        if remaining_space > 0:
            if align == "right":
                lines[i] = remaining_space * " " + line
                pass
            elif align == "center":
                left_padding = remaining_space // 2
                right_padding = remaining_space - left_padding
                lines[i] = left_padding * " " + line + right_padding * " "
                pass

    if len(lines):
        for line in lines:
            output_buffers = brainlet(line)
            for output_buffer in output_buffers:
                print("".join(output_buffer))
    else:
        print("\n\n")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("text", nargs="*", help="the text to render")
    parser.add_argument("-w", "--width", type=int, help="number of chars until wrap, or zero for no wrapping")
    parser.add_argument("-a", "--align", choices=["left", "center", "right"], help="align the text of multiple lines")
    args = parser.parse_args(sys.argv[1:])

    width = None
    if args.width is not None:
        if args.width > 0:
            width = args.width
        elif args.align == "right" or args.align == "center":
            print("brainlet: cannot align without a width", file=sys.stderr)
            exit(2)
    else:
        if sys.stdout.isatty():
            bounds = shutil.get_terminal_size((-1, -1))
            if bounds.columns >= 3:
                width = bounds.columns // 3
            else:
                width = 80 // 3
        else:
            width = 80 // 3

    if len(args.text):
        print_brainlet(" ".join(args.text), args.align, width)
    else:
        try:
            for line in sys.stdin:
                if line.endswith("\n"):
                    line = line[:-1]
                print_brainlet(line, args.align, width)
        except EOFError:
            exit(0)
        except KeyboardInterrupt:
            print()
            exit(1)

if __name__ == "__main__":
    main()
